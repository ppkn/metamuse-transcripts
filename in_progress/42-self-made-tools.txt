Linus Lee (00:00):
Building my own tools. When I type a character in or hit save, I know exactly where the bits are going. And I think that changes the relationship that you have with your software. There is kind of a power dynamic where if you don't know what the company that's providing you some software product is doing with your data. They have the power. Whereas if you build your own thing, you understand exactly what's going on. You are in control.

Adam Wiggins (00:25):
Hello and welcome to Metamuse. Muse is a tool for thought on iPad. But this podcast isn't about Muse the product. It's about Muse the company and the small team behind it. My name's Adam Wiggins. I'm here with Mark McGranaghan.

Mark McGranaghan (00:37):
Hey Adam.

Adam Wiggins (00:38):
Joined today by Linus Lee.

Linus Lee (00:40):
Hello, hello.

Adam Wiggins (00:41):
And Linus. Before the call, you were showing me on video chat here. You have a fun new gadget. Maybe the audience would like to hear about that one.

Linus Lee (00:51):
Yeah. This is always good audio podcast material. When you have to show something off visually. So I recently got this thing called a Surface Duo, which is an Android phone from Microsoft, but the Android, part's not super interesting. What's interesting. Is it folds out like a book. It's about the size of a passport. And if you imagine your passport folds out and there's screens on both sides of the book and there's like a stylus you can use on it. And it's meant to be sort of like a multitasking multi-screen note taking on the go productivity phone.

Adam Wiggins (01:20):
And the screen there is continuous, that's using the folding screen technology. Is there a seam there?

Linus Lee (01:25):
There's a solid seam there. It's two separate screens, but it's like, if you imagine like a Nintendo DS from way back when, tilted on its side

Adam Wiggins (01:33):
Or yeah, maybe a shrunk down multi-monitor setup.

Linus Lee (01:36):
Yeah, exactly. And it's great for reading great for like general kind of content consumption, taking notes, things like that. Not so great for like watching videos or like Instagram really struggles to fit on that screen. Cause it's basically square. But yeah, I've been enjoying using actually one of the perks of living in New York rather is that all the tech stores are just lined up right down fifth avenue. So I can go. Cause when I got running, Microsoft came up with a new one, I think just last week or something like that. And I went down yesterday to visit him. They didn't quite have it on the shelf yet, but maybe soon maybe I'll upgrade.

Adam Wiggins (02:08):
Microsoft service line has continued to impress me. We did a quite a bit of prototyping on one of the surface tablets from few years back. And just in general, what they've done, they're kind of going into hardware and doing such a good job at it is really quite impressive for especially such an established company, which are not known for that kind of innovation or moving into brand new markets and do a good job.

Linus Lee (02:32):
Yeah, definitely. It seems like they sort of see their responsibility is doing things that are weird. They very reluctantly did like a classic laptop form factor.

Adam Wiggins (02:42):
Yeah, I like it. And could you tell the audience a little bit about your background and interests?

Linus Lee (02:47):
Yes. So my name's Lynas, I said grew up in Indiana, which is where I spent most of my childhood before that I spent first half of my childhood in Korea, just from my family's from, but I grew up in Indiana, like normal kind of public high school versus the end of that high school experience. I kind of self-taught myself. How to code Java, script, backbone, react kind of stuff. And then got a little job over the summer at a software startup in the area called Spencer. We did agriculture precision agriculture software. So basically using some hardware out in the field. Well, Indiana is a farming state. So hardware in the field, plus some weather data and satellite imagery and other things like that to try to improve efficiency and ease of producing food for humans and for cattle and so forth. And so I was there for about that summer and then ended up taking a year off after high school to work there, learning Django and Java scripts and all that good stuff.

Linus Lee (03:44):
And that was my first kind of real programming gig. I learned a lot there for about two years. And then after that, the company itself ended up getting bought. Then I had a few extra months to travel and things like that then went to UC Berkeley where I studied computer science for a few years, which is in California. So went to Silicon valley, did some other startup stuff was briefly a part of things like replica online ITE. Oh yeah, they're doing some pretty cool stuff and a couple other projects. And then recently I moved to New York just right now working at a software startup, doing sort of tools for thought space things, all the idea flow. And then all through that time sort of off on the side have also been doing random other experiments, building my own various projects and writing a little bit and things like that, which I'm sure we'll get more into.

Adam Wiggins (04:32):
Yeah. Well I would think looking over your home page and your Twitter account and your blog posts that these, what you call side projects appear to me, like they could easily be a full-time worth of output. So doing that on the side from your regular work, as opposed to, I don't know, a retired gentleman who can spend his full day building interesting tools certainly speaks impressively to your output or maybe passion for building these tools.

Linus Lee (05:00):
Yeah. That's a misconception that I've gotten a couple of other times. I think it's actually interesting to think about like having to work a normal job, like not being completely free on your own to follow all your whimsical ideas and having a bit of constraint on not only your time, but also like having to use normal note taking tools and having to like use notion and talk to people in slack and things like that, I think is a good kind of way to ground yourself.

Adam Wiggins (05:25):
Yeah. We actually see this dichotomy in the, we call it the research world or even in like a classic software company that has maybe like an R and D arm with sort of mad scientists thinking big ivory tower thoughts versus the more kind of production like please our customers keep our systems running thing. And you typically have, if you're too much in the research, free floating, just have big ideas. You're not constrained by the realities of the market or customers or anything else. You just add a touch and it's hard to like make things that are meaningful. But of course, on the other side of the equation, if you really deep in the trenches of doing a Atlas, holding up the world kind of thing with production systems and you're thinking about tomorrow and next week, and you just can't have big open out of the box thoughts or like you said, to explore weird wins or unusual directions. So it's a difficult dichotomy. It seems like you're walking that line though.

Linus Lee (06:20):
Yes. Yes, definitely.

Adam Wiggins (06:22):
So our topic today is self-made tools and of course Linus your work is a stellar example. That'll link to some posts here. Maybe monocle is an interesting one here. You have a post explaining your motivation for that. And there's a few other posts we can reference here. Other folks I know who are really prolific self-made toolmakers, but yeah. What does that mean for you? What are self-made tools? Why do you do it and is it something you recommend others explore or is it only for a certain kind of person? Maybe.

Linus Lee (06:51):
Yeah. So the way that it look it's definitely tools is a lot of the software that I rely on to function as a working human day-to-day are things that I built myself to varying degrees. I have notes apps that I've built that I use to keep sort of my personal information. And in general a little bit, I have obviously things like my website and other kinds of public presence, things, but also like a contact SAP CRM, your typical productivity. So we kind of stuff. And then, because these are just sort of like things that I imagined. And then I go build, there's also things that sort of don't exist as general purpose things in the market that I've built out like a personal search engine, which is the Monaco that you referenced earlier, where I have all my data is sort of shoveled into a search index.

Linus Lee (07:32):
And then I can search for anything across any of my sort of bank of data from people that I've met to conversations that I've had to websites that I've bookmarked and things like that. So some of them, or sort of what you would normally imagine as side projects like off the shelf, libraries and frameworks and things combined into things that I put on in the cloud and other ones are more involved. Monocle, I think is a good example where the search index that I use for that is one that I built myself. It was originally a project to learn how kind of full text search worked. And then that has been written in a programming language that I wrote called ink. And the stack kind of goes very deep into that. But yeah, things that I've built myself to fix my own problems or assault my own solutions or solve my own problems, I guess, and really for myself only nobody else. I'm going to guess if you want it to, you could go to get up and clone those down and deploy yourself, but a vanishingly, small number of people do that. And so it's mostly just for me to use

Adam Wiggins (08:29):
As you sit there and describe writing your own full text search engine, writing your own programming language, sort of not just the end application, but really going down the stack. I'm reminded of this as basically a meme now, but I think it's like an excerpt from a movie where there's a guy that wants to change a light bulb. So then he goes to get the light bulb out of the cabinet, but then it turns out that the cabins cattle loose things that he's going to get the screwdriver, but then the screwdriver, it turns out those in the squeaky drawer. And then at the end, I think like this wife comes home, what are you doing? He's like, I'm changing the light, obviously. So it feels like with technology and software systems today, I mean the stack goes very, very deep. How do you decide when to like stop diving down? I guess another way to put it was how much is the decision to say, for example, write your own full text search. Is that a pragmatic decision versus following your curiosity? You want to learn how this works?

Linus Lee (09:21):
Yeah, I mean to the question of when do I stop, it's really when my curiosity stops being strong enough to get me through learning, whatever I have to learn back months and months ago when I was more naive. I mean, this is all endless yak shaving, right? Like God, I need a note taking app. And then I realized I need a front end library. And then I realized I needed a programming language. And there was a point in time when I was sort of made to myself the arguments that ultimately this was sort of a more productive way to work because in the end the little time that I take to build my own tools, it's going to kind of come back because it's sort of so fit to the way that I think and things like that. And I think to some degree that's still true and that when I'm really in the flow and more productive with the tools that I built, but I think really the argument that building your own kind of software ecosystem is more productive, may be a little flawed, but I think a change in mindset that I've had is, I mean, I still do it.

Linus Lee (10:13):
And so there's still has to be a good reason to do it. And I think for me that reason is that it just changes the relationship that I have to, the software that I use and that if it's my own tools that I built on top of my own stack, running on, it runs on the cloud. I use digital ocean, so I don't want to control everything, but to a large extent running on sort of things that I understand I can trust it more. It feels more personal. I mean, I may yet sort of handmade it obviously. And so I think it changes the relationship that I have at the software that I use and the data that I get to keep on it and trust it a little more and makes it feel more, little more personal and doable. And so I think that's the benefit.

Linus Lee (10:51):
And on the along the side, I get to kind of learn a lot, right. A lot of my side projects are motivated by just encountering some new piece of technology that I don't understand. And then I use building a kind of prototype clone of whatever I'm trying to learn, how something works. I use that as the excuse to like build another tool like the search engine, or I have like a toy assembler that I made, which I don't need to assemble x86 code very often. So I don't use that as much, but it was cool learning project.

Adam Wiggins (11:21):
Yeah. I really like the personalization angle. I think there's also this element of agency or self-actualization or something like that that fits into this same theme. You know, we had way, way shoe in the podcast. For example, we talked about the fact that you have this homogenizing effect of now that most technology is made by these absolutely massive companies that are practically nation states. And then of course they're appealing to the widest possible audience and that fits into that kind of software. Yeah. Basically the wider an audience you reach with your software, you know, the more you can become one of these huge empires, but then very much lost in that is not just sort of niche software, but also just things that are weird, different appealing to a smaller audience. And in a way the personalization side is, you know, when you're making something just for yourself or just for yourself in the small group, that's about as personal as it gets, it's a nice antithesis or pallet cleanser or something from, let's say the mass produced software. That honestly is what rules our lives now.

Linus Lee (12:23):
Right? Definitely a phenomenon of like every SAS website looking like the Stripe, but a little bit worse. We were talking about something related right before the show about how there's sort of two bifurcating kind of classes of software. The one that you just referenced, the kind of big company, one is things that are meant to be sort of lines of business, things that companies sell to other companies or other people. And they sort of have a tendency to grow indefinitely. Like you build a prototype, you start selling it, people need more things. And so kind of grows on bounded Lilly, both in terms of like feature setting complexity and technical debt, but also in terms of just code base complexity, it's just easier to add things when you need the product to do newer things and more things. Whereas the idea of situated software, where you have a very finite group of people you're building for and a very fine like use case, you're building four, which is frequently what I think my tools are.

Linus Lee (13:16):
I just need it to do these three things, take my notes, save them. I want to be able to read them. I'm gonna be able to send it to these places or receive some notes from these places. And I know exactly what I want. Maybe I'll want to add one or two things there, but it's definitely not going to grow. Undoubtedly. It's definitely meant for only me or only the small group of people. And I don't really care if that many people use it. It's sort of an underrated group of software, but I think there's places where it's the right thing.

Mark McGranaghan (13:41):
Yeah. And just to riff on this piece a little bit. So I agree with all of the sort of first order reasons we gave around and it can be more fun. You get to learn, you have potential for it to be more fit for purpose for you personally. But there's also interesting second order effects with this focusing. So you talked about how the general purpose tools they have, all of these layers that are built up over time because they need to serve a lot of use cases, right? And with all of those layers, even if you have a very focused use case for the software, you're kind of stuck with those because the layer is they end up coupled with each other and you have all these weird linkages. So you can't just boot out some piece of it. So for example, if you want to make a very basic static site, well, okay, now you need the static site generator, and now you need a library system, you need a package manager and you need a way to install the package manager in a way to check for security vulnerabilities and all the packages.

Mark McGranaghan (14:31):
You need a web server, you need a place to run the app. It's a whole thing, right? And even if you have a very basic site, you're kind of stuck with all that. And so what I like about these very simple projects is you have a possibility to do what I call stack fusion based on the similar idea from algorithms of stream fusion, which is kind of looking at the whole thing and what you're actually trying to do, and like compacting it down to the minimal possible stack. The example that I like to give is these webpages I've done where my stack is. Like I opened up indexed, HTML type type type save that's the website. And that's a very basic and almost contrived example. Right. But it just shows how much stuff you could potentially get rid of if you are able to do this sort of stack fusion.

Linus Lee (15:11):
Yeah. I like that a lot. I think one of the questions that I get about, I guess at this point in my personal infrastructure is what you can call it is for example, authentication, you'll ask how I do authentication because there is no kind of authentication, but they did code in any of the open source code that are released. And the reason is because at the app level, I don't do any authentication because all my stuff lives on a single Linux server. And I just have one giant authentication layer at the top, um, that their kind of reverse proxy they are. And then once any request goes through that layer for anything that needs to be authenticated, I can assume that it's me. And then I have all the permissions that I want. And I like the idea of would you call it stack fusion of just if you know a lot about the environment that you're deploying on, who's going to be using it and things like that.

Linus Lee (15:53):
You can make a lot of assumptions that let you not need a bunch of these abstractions instead of when you kind of collect the sample is when you need to deploy a search engine, you don't have to start with, I'm going to start up a crawler. I'm going to start up a database. I statically regenerate my search index every once in a while, it goes into a file. That file is loaded to the browser. And then the browser does a search. I don't need any kind of sophisticated database or ingestion algorithm or anything like that.

Mark McGranaghan (16:19):
And this leads to further third order benefits, because if you successfully do the stack fusion, you have much more ability to understand all the pieces work and you potentially have more durability. A lot of that complexity is often to support like dynamism and change, which is a direct liability in terms of erosion of the stack. But if you have files on a Linux server, there's fewer ways that I can go wrong. Then a whole dynamic database is doing authentication. And so on Adam, you might be able to speak to this because I know this was a motivation for you with Brochu.

Adam Wiggins (16:51):
Yeah, for sure. And the bit rot or software erosion, the idea that a piece of software that worked at one time doesn't work anymore, even though nothing changed with it, which always seems weird because software is digital. Why should it not work the same every time? And the answer is that the world changes around it. Sometimes in small ways you have an operating system upgrade. Some things were changed and I dunno how paths are parsed or something like that. But often in big ways, for me, one of the biggest disruptions in my personal tooling was I used to write a lot of things with a little Ruby scripts around at the command line that worked great. When the only kind of computer I used was what we call a desktop class computer. Once the phone became a huge part of my computing life, now that doesn't fit in or the world has changed in a way that those pieces of software don't fit into it as well as they once did.

Adam Wiggins (17:41):
But one of my motivations at Roku, yeah, for sure. It was, I felt like hobby projects and interesting side projects. And even at a, what you might call, yeah, we should talk more about the situate and software label, but you often have this case where I did this at companies, I worked for companies I consulted for, and you also see it often as spreadsheets or file Macro-Pro things or whatever. But sometimes also web apps would be something where one person would build a custom tool for just that team, whether it's five people or 10 people or 20 people, and they would set it up and it would be running over a ton as a web app. So often it would stop working. Database goes down, server needs a reboot. The file system is full because the log rotation thing wasn't set properly. And so one of the things we strive for with Roku is to make these more explicit contracts with the underlying systems so that you could more easily upgrade things and have the platform do a lot more of that maintenance kind of automatically. And hopefully the app could keep running over the longterm. I think there's no perfect way to ever do that. I think we did make some good strides there in terms of reducing the likelihood of that software erosion. And I'll link out to the article we did about that.

Linus Lee (18:51):
Yeah. I want to also take it a little more into the kind of dynamism, ease of making changes thing, because I think there's actually two ways to look at the ease of making changes when you solve a problem with software. But one way is to make the software sufficiently sophisticated so that you can swap any arbitrary part out and you can keep making changes. The other is to make the software so simple that it's easy to rewrite and you can just rewrite it when the constraints change now. And the way you do that is you make your data layer more portable. You use a lot of my data is stored in Eulando minute, Jason, just lines of Jason unpacking dosing file or text files, remarked on file or something like that. Where like basically any tool that I pull it and it's going to be able to talk to it, or if I really need to structure something like SQL, you know, you can plug that into basically any language.

Linus Lee (19:39):
And it makes things like backup really easy. Cause you just copy the file and things like flat dependency trees. So if you don't depend a lot of things, it's easy to rebuild things and you make sure that the earth doesn't shift under you quite as much, if you write relatively small things that do one or two jobs only then if the constraints change a little bit, maybe you can just modify the software a little bit. But if the world changes a lot, it's not the end of the world and you can scrap it and rewrite it or something like that. I try not to rewrite things too much. I try to make most of my things last a while, but I've rewritten some of the older pieces of the things I've been using, the notes happened, things like that, which I wrote that's spent five, six years ago. I've written those a couple of times just because the world changed in some of the packages that are used to use the aged out. And so it didn't take too long.

Adam Wiggins (20:26):
Yeah. Some other stuff on the durability that I think we talked about a bit before. I know mark, you would have maybe one of the ones who might as to the value of the go and static linking. So the sort of dynamically linked libraries, whether it's DLLs on windows or the data, so files on Linux, you think of as being sort of a necessity for modern software, but go just says, screw all that. It's too complicated. It's likely to break now. You're like tying things together. Let's just package it all together and you know, computers are fast and we have stored. So it's fine.

Mark McGranaghan (20:58):
Yeah, exactly. I like that aesthetic.

Linus Lee (21:00):
Yeah. I like go and similar kinds of philosophies and the tools that I use for the same reason where it's as someone who maintains a few dozen different things that are sort of concurrently running online. It's very difficult to think about doing that while running on an ecosystem like node. I love node JavaScript. It's great. But one of the faults that has is like every project has a million dependencies and by the time you're done with the next project, the old project is about a date. And so it's difficult to think about operating in the style of like many, many different small projects with an ecosystem like that. Whereas with go or one of the benefits of writing your own language is that the language only makes breaking changes when you decide to make breaking changes on your own terms. And so using languages that prioritize long-term durability of software, I think helps a lot on things like static, linking I think is a reflection of that value. Yeah.

Mark McGranaghan (21:50):
And by the way, this go discussion reminds me of a generalization of the personally built software question, which is if you are a company or organization, should you use something off the shelf or should you build it yourself? I don't think we want to go into that whole discussion, but I'll just know that there are a lot of echoes in the analysis and that calculus between an individual and a corporate. And I was thinking about with go because in the same way that people will often tell you, they should always just use a library off the shelf. I'm sure. At one point everyone said, why would you ever write a programming language? Well, it turns out it was the correct thing to do. It does important things that no language had correctly brought all together. And so I think there's a similar dynamic playing out with personal software and with corporate choice to use libraries versus building.

Linus Lee (22:34):
Definitely one thing that you touched on there is the idea of like leverage and doing your own tools, that various levels in the stack where at some level of like operational scale or a software development scale, if believing in your own primary language makes sense, because it gives a greater leverage over the things that make your job easy or hard. Yeah. And I think that doesn't just apply at the programming language level that also applies to your life at the tool level. So let's say like a lot of your work is about remembering people and keeping relationships with people, maybe designing your own CRM or context app gives you that extra leverage. Or maybe if your job is about taking a lot of notes and learning a lot building notes for yourself actually does give you that leverage. And so there's a whole thing with not invented here syndrome, which we don't have to get into. But I think that's one way to think about it is in the long-term will it pay off for me to have this sort of deep understanding and control over what I use and depend on? Yeah,

Mark McGranaghan (23:24):
I do also think there's another side to this, which is, are now of the calculus has been very focused on the abilities, you know, the durability, the flexibility, the understandability, and that's all important and that goes into the calculus. But I also think there's a artistic element of sometimes to make a statement about how you think the world should work. The only way to do it is you just do it all yourself top to bottom. And I do think that comes through sometimes with these personal software projects and even some of these libraries and other software endeavors, the initially seemed like a weird thing to try to go out and do, but ultimately you see that not only are they providing ilities, but they ended up making a statement about the world, which I think is cool. And I think people underestimate how important that is.

Linus Lee (24:03):
Yes, definitely. That reminds me of one of my favorite others sort of self-made software people is this couple of people called a hundred rabbits and if you've come across them, but oh yeah, yeah. They have a little boat I think called the Pino and they sell down from Vancouver and Australia to Japan and they're just open source hackers on a boat. And they also have their own sort of Homebrew software stack basically from the like language virtual machine up for various things, a lot of [inaudible] and old school software things, things that don't break things to do consume a lot energy, certainly no electron apps. I think actually they've publicly said that running instances of Chrome is untenable for them because they only have a limited amount of energy from those solar powered things on their boat and they have to be really efficient with it. But I think that's a great example of building your own tools or building your own software stack, not purely for the utility that it provides in your life, but as a demonstration of this is possible, or these are the values that I believe in, which I think is, as you said, also important,

Adam Wiggins (25:04):
The one that comes to mind for me on that, and these are publicly available, but fellow named Jordan singer has little laps. It's just a calculator at draw tool browser can, and these are all things that come by default on modern smartphones or whatever, but he has a particular aesthetic and a particular just kind of minimalist just does the littlest thing possible and slow. And yeah, it just has a particular style to express. It's not that those tools provide utility. You can't get elsewhere. It's more like they express something about how their creator sees the world.

Linus Lee (25:38):
Speaking of little, one of the nice things about building your own thing is computers are very fast these days. I don't think most people realize how fast computers are these days. And the reason that software is slow is because it turns out we write a lot of code and we make computers execute. A lot of code, a modern desktop computer can run two to 4 billion destructions per second on a single core. And if your slack, or if your whatever app takes up a second to start up, what is it doing with all this billing instructions? Like you just have to show a rectangle on the screen. It's wild. And fortunately, if you write your own thing, there's only so many lines of codes that I can pack into my little project as a single person hacking on over a weekend. And so by virtue of that and very little else, all my things are really fast. Like my notes app loads faster than it takes for notion to start showing it's spinner to load the rest of the page. And those things about building little things are also nice. Things like performance and sort of consistent design aesthetics and things like that. You get for free.

Adam Wiggins (26:39):
Now we've talked about, these are sort of personal tools, personalization. You're building for yourself and sort of your target audience of one. And that person is the same person making it. And that also makes me think of a fellow I've worked with closely named Shamone Kalinski, who does a lot of personal tracking tools and things like that. He's also a musician and he makes a lot of music tools I'll link out to his portfolio. So he's maybe in the same category as you in terms of making for himself and that's it most of the time, but then you have something like, and a lot of my experiences with this more like situated software is often creating for small group outside their group of friends. A family can also be obviously very much in the corporate call it enterprise environments, you know, just small team that has a need. And I'm thinking they're a Robin Sloan's concept of home cooked. An app can be like a home cooked meal. He's got a lovable kind of messaging app for his family that he wrote about I'll link that in the show notes as well. So how often do you find either of you are writing when you're doing this sort of work, are you writing for just yourself versus a very small group?

Linus Lee (27:45):
Yeah, that's an interesting question. I think in my experience, most of the things that I ended up building or for just myself, almost all my work is online, just because, yeah, there's no reason to keep it to myself. If other people want to look at it, you can look at it. And I like writing a little read me as, and things like that. Well,

Adam Wiggins (28:03):
Of curiosity, what happens in that case? When someone submits a bug report, a pull request, a feature requests, he say, no, you got the wrong idea. This is for me not you or

Linus Lee (28:12):
Yeah, I mean, sometimes it depends a good example is my programming language. A lot of the reasons that I have it is it's not at all because I have this grand vision of like, I think this is how programming should work. And these are the features that it should. It's just, I did a university project once, right? Built like a lisp interpreter, which I think is like a common college project. And I was like, oh, this is cool. Maybe I should be able to build a whole language like this and I can decide what all the keywords are and that'll be the thing, right. Instead of saying, function can say fun because I like to keep track. And so it's a reflection of just my taste for those things. If other people want to come in and kind of speak their opinions, I say, thanks for your opinions, but this is my language.

Linus Lee (28:51):
You can fork it and I'll help you fork and understand the code base. But for my thing, I want to keep it to my tastes and that's totally fine. But for some other things, for example, I have a little tour client that I use, like a Twitter reader that just talks to the, of API, but gives me my own kind of chronological timeline and a few other kind of search niceties. And for things like that, other people have come along and they've contributed things like a Docker file for people to more easily cluttered and use it on their own setting and things like that. And sometimes, actually the Twitter thing is really interesting because it's designed to be sort of in one very specific way and user customizable, which is that you can add these tabs that correspond to searches instead of just having your own timeline, your home timeline is just one of the many TweetDeck style.

Linus Lee (29:38):
One of the many tabs that you can have open and you can have another tab. That's like people talking about tools for thought, or you can have another tablets like Taylor swift content or whatever big fan. And maybe that means that other people don't have to contribute patches or it could put in pull requests because it's like end user programmable thrown a buzzword there, but it's end user programmable. And so in that way, maybe people don't have to modify the software itself for the thing to suit their needs, but yeah, pull requests come in. If it doesn't really change the way that I use it, I'm open to it a lot of the times because it is an improvement, but if it impacts the way that I use it, then, you know, I built that for myself. And so you can fork it, fork it, yeah. Build your own version, then matches your own tastes. Yeah, definitely. And I'm actually a huge fan of that. You can forgiven the winner will get the masses kind of approached opensource.

Mark McGranaghan (30:28):
And I think by the way, that aligns well with having artistic goals because in that world, the actual code repository is not so much the output as the instigation that you've admitted into the world. This, I think was a success of go by example where I don't think anyone has used the actual code base, but people have used the X by example idea and layout a lot. And that's propagated,

Linus Lee (30:51):
Which is great. Certainly I think this is true of Monaco as well though. Search engine thing. We're just building that. I think it's one of those ideas where you tweet it out and in the thread, there's a bunch of people who are like, I've been thinking about building a personal stretching for India for the last five years and oh, why haven't you done it? It's because there isn't that instigator to say, this is doable. And these are the ways that you can do it. And one of the pure joy moments of building my own tools on and putting it out in the world like this is seeing other people take those ideas and either take the code base or just take the idea and go and build their own tools. Because it's really lovely to see against the kind of tsunami of these like corporate mass-market tools, these little small islands of personal tools that are reflections of the maker's values and tastes kind of come into play. Yeah.

Mark McGranaghan (31:38):
I think as an empirical observation, there is a very base step function and like difficulty and effort when you go from one person to end users, especially in our classic SAS model of client server, where the server is, multi-tenanted, there's all kinds of complications you have to code base. You have multitenancy, you have security, you have upgrades, you have different versions across the client and server. It's a whole idea. Also, I think in practice that stops a lot of people and equals one and they say, you know, just basically go fork it and do whatever you want. I do think there's a world where this step function is decreased a lot. And this goes back to our discussion of local for software. If you can have something more like spreadsheets where you can just send someone one file and that's basically all they need to be able to participate in this home cooked meal, I think it could be much more successful. In fact, we see this with spreadsheets, often there's groups of friends or groups of colleagues at a company where they're sort of sending around or linking around or forking a spreadsheet. And it sort of spreads as a meme within a company. I could see the same thing with local, for software, if you didn't need a server. And if all the data was either stored directly on the client, or you could bring your own server. And so the originator of the software didn't need to worry about multi-tenant hosting or data.

Adam Wiggins (32:49):
Yeah. The authentication identity generally, of course, is just kind of this huge unsolved problem throw in the multitenancy you throw in the partitioning by users. Even if you leave out security thing, assume that all your users or friends or family members are in the same company or something like that, it just quickly gets very, very complicated compared to the, maybe the world of software that I sort of grew up in, which is something where when you write a program, maybe saves data precipitated to disk by writing a file, which is incredibly symbol. As you said earlier, they're like, copy it. You can delete it. You have a lot of agency over it without needing to build that into the tool, the app. And yeah, the concept of user just doesn't really exist or it's implicit in, for example, your local Unix user or something like that.

Adam Wiggins (33:37):
The permissions are all handled by the operating system, the location and the file system is handled by the operating system. You just write the program and all the rest can go around it. And that's kinda not where we're at in a way modern operating systems, whether they be on the desktop or mobile do way, way more, or even the web has way more API has way more capabilities, accessing hardware, all these different things you can do. But in a way, some of these simpler things like just knowing who the user is, you could do that in a Unix program. There's a, who am I, you know, function? And you can kind of inherit that from the operating system or file permission to can inherit from the operating system. Basically, every app is reimplementing all of that from scratch in the modern world.

Mark McGranaghan (34:21):
Now that we're talking about it, I have another example. So long time listeners of the podcast will know that there's often two examples. We drawn. One is spreadsheets. And one is games as areas that have in many ways at the frontier of computing. So now I'm thinking about sort of situated or home cooks software in a context of games. And there, I do think you see it with the like scripting and modern community. So you have these games where there's an existing infrastructure for players and accounts and identities and server hosting and everything. And people can contribute their own programs in the form of different skins or different maps scripts. And that is very successful because again, you just need to basically put your code, if you will, out there, people can share it around and copy it around and link it around. And that's all you need. You don't need to run your own map, hosting server or whatever that's been very successful. It makes me think even more that if you could have a similar substrate in the world of personal knowledge management or more traditional SAS apps, you could see the same success.

Linus Lee (35:17):
Yeah, definitely. I think mark, what you've been talking about sort of made me go on a train of thought about software packaging, because a lot of this is about how do we take something that works on my computer and make it so that other people can just take it and run it. And it works the same other computer and in a similar way to what we're kind of talking about. I think the adamant of get hub as the de facto that people share code, I think it was kind of one of those step function changes, right? About yep. Instead of sending me a zip archive or sending me patches, you can just send me a link and then I can download it in cloud. And oftentimes there's instructions in the Rigo of how to run it. And presumably there is more that we can go down that route about, instead of having to copy a whole bunch of files down and then set all these things up and things like deploy AWS with all this scripts and stuff. Maybe you can just give me a file and I can run it and it'll just work. And I think that, yeah, there's a lot that we can still improve on, on the packaging side. I think for just being able to share sort of single user single instance, pieces of software. Yeah.

Adam Wiggins (36:12):
In a way I'm nostalgic for the windows era of download any XC and run it. And I know why in the world of malware and so on that maybe doesn't work anymore, but there was something quite simple and elegant about it. And because Microsoft did work so hard at kind of keeping backwards compatibility in the operating system, you typically knew that yeah, someone wrote compiled and 10 years ago and you can still run it on a windows computer today. The closest thing we have with that now, or the best thing I would say is the web where typing a URL into your URL bar is essentially downloading and running a program on the fly, in a safe sandbox, which is frankly a miracle when I stopped to think about how that works, but it has these limitations of things you can't do. It's not personal.

Adam Wiggins (37:00):
If you want to do anything with, you know, it's going to have some kind of persistence that really needs to have a backend. And now you're into this whole crazy world of different tools and you need to know five different programming languages just to make the most basic thing, you know, shared to-do list or something work and yeah, a world of local first apps or something where you could download a piece of software, expect to run, have it be in a security sandbox to the safe, but not necessarily to go through some kind of gatekeeping review system and then be able to do persistence and other things that you would do and local environment, or even add in some of the collaboration side of things. I would be very disappointed if we don't end up at a world there sometime in the coming years, but I also don't know the path that gets us through there because the companies with the most resources and software engineers throw at the problem are pretty motivated to keep their walled gardens and keep you logging into their system and keep you on their servers rather than empower local, more powerful local apps.

Linus Lee (38:04):
Speaking of being able to download any and run it through, I think there is a momentum in that direction. I think one example that has been quite a big source of inspiration as I work on my own programming language kind of tooling and ecosystem is Dino Dino. There's no JS. And then Dan was sort of the TypeScript runtime, I think just the way they talk about it, but it's out of the same underlying technology as node, but it runs sort of TypeScript natively has a built in test script compiler and some other things in the language and that's all fine. But the really interesting thing is Deno inherits kind of big focus on developer experience and tooling quality from other languages like go and rest. And so I think in the kind of intervening 15 years, they've learned a lot about how to distribute and package software.

Linus Lee (38:47):
Like a lot of the big focus of no JS was just like, let's get asynchronous events. API is really good. And like they got that, but everything else is kind of a mess. And then, you know, I think a lot of the right choices have been made for kind of software durability. So you can do things like dinner compile, which gets you an executable binary. So you can write things with TypeScript and build it with dyno and package it up so that I can give you any equity and you can run it on any Linux thing. Right. And I think things like that sort of being built into the language tool chain are pushing us, I think, in the right direction. The other thing that tenor does that's really interesting is instead of having a package registry, the packages that you can import are just kind of URLs. And so you say import X from this URL string and it will download it and cache that thing at that URL, but then there's no intermediator that has to be up all the time, or that has to be correct all the time. You're just downloading things from the web, which I think is about as future proof as you could get.

Adam Wiggins (39:39):
Yeah. Another interesting thing about Dano and that's a smaller point, but I think it's an important one, which is this sandboxing thing is so important for making it possible to, I can give my friend a piece of software that I've written and they can just run it. And we don't need to go through some onerous review process, but we obviously also need to protect from the now huge world of malware. And so sandboxing and good sandboxing is a potential technical solution to at least some elements of that. And the browser obviously does an incredible job at that. But if you want to run a command line program, no, the dental actually does a lot of that. Where by default, any dental program you run, the command line has no permissions essentially to the core operating system, but you can pass it switches to say, I want it to be able to, for example, make an outbound HTTP request to this host, or I want to give it full network access or something like that.

Adam Wiggins (40:30):
So you have a lot of that kind of control that I associate with, for example, cubes, OMS. So that sandboxing gives you a lot of control over the individual programs, how they're accessing the network or the file system, that sort of thing, while at the same time, just giving you the incredible simplicity, which I still love that you had from Ruby and Python. And of course go and Russ nowadays leading back to the sea days, which is you just have file and you type run this file at the command line, or you double click it or whatever it is, the thing just runs. And you compare that to, you know, what it takes to sort of run a web app, particularly a database back web app. That's just incredible simplicity that I think can do the job in a lot of cases, especially for these self-made or situated apps.

Linus Lee (41:15):
Yeah. Actually one thing that people say around software packaging is that the modern analog of the exe is like the Docker container. And I think sort of aspirationally that's in the right direction where instead of having a single battery that you can run a Docker is sort of the representation of a thing that you can put on a machine and have a run. If you need an entire system set up, then you can have whatever confirmation Yamhill or whatever. You can just throw it to a cloud provider and it'll spin up the whole thing. And I think that's aspirationally in the right direction. Like that's where we want to get to. And I think if the dreams are fulfilled, that's, that's a really interesting world where you can give your friend a confirmation Yammel and they'll just spin up their own little thing. But in practice, just quality of experience wise, that's much easier to execute and exceed and to throw it up on a web service. Maybe there's a gap that we can fill there. But yeah, it's interesting to think about sort of in this world of having a backend service and databases and then users and things like that in a web app, what that equivalent to executing the binary experience looks like.

Adam Wiggins (42:16):
I think in my ideal world, you would somehow put together, I guess the client side version of the Docker cubes, OOS virtualizations sandbox thing would be, imagine a launch, an application launch screen. That's like the iPad home screen. Basically I could drop a Docker file essentially on their own to become an app icon. And when I tap the app icon, it fetches, whatever it needs to fetch to run it spins up a virtual machine and runs it and gives it to the computer full screen until the exit, something like that. That just makes it very, very easy. In fact standard, totally standardized to just spin it virtual machine and run it. And maybe there's a server side version of that as well. And certainly some, I think platform, those services have attempted this. Certainly somebody there'll be a services have steps, this something where you really do just have maybe Heroku the Heroku button was the equivalent of that drop a little link onto your GitHub, read me and you click this button and it kind of spins you up a virtual instance of whatever this application is. So we've had some good stabs at that to try to at least package up the complexity, if not remove it or simplify it, we have quite maybe got that. Perfect. There's still no doubt the DXE equivalent.

Mark McGranaghan (43:27):
Yeah. Yeah. And I think there's a couple of things missing here. I think on the one hand there's additional platform primitives that are needed for things like identity and data. If you're really going to do this without having your whole full clients, everything, which is necessarily a lot of hassle, but also these things like Docker and virtualization so forth, they are sort of the opposite of stack fusion. It's like, we're going to run any stack. You want, you know, any language, you know, 10,000 files in your node modules or whatever, you know, go for it. And that's awesome because it gives you a way to better manage all this existing complexity that's out in the world. People need and want that. But it might be that if you want a really nice click experience that you need to do a bunch of stack fusion and say, okay, these are the API APIs. They're much, much narrower than also wants to ask. Maybe only one programming language. Maybe you don't have your full suite of wilds calls or whatever. Maybe you can contact any address in the networking or you figure out what's a very narrow interface, but by accepting that narrow nest accepting that fusion, you can give a much more powerful experience to the home cook app developer.

Linus Lee (44:26):
Yeah. One thing that's come to mind is we have this conversation is the metaphor of the app as a thing that you can hold and move around, as opposed to a thing that you install on a system, it used to be a windows user. And then these days I kind of use Mac and Linux. And one of the really interesting things with like max, like not the underlying software model of applications installing the system, but just the end user model of how the Mac works with applications is that there is like a.app file. And there's like safari.app. And that's as far as the app, and if you want to get rid of it, you just take that file and you move it to the trash. Yeah. And if you want to open it, just open it, you can move it to a different part of the folder or something like that, compared to an windows, for example, where you have an installer.

Linus Lee (45:06):
I mean, you can have any exit too, but it's just spraying files everywhere. Like messes with a registry. I like put some weird stuff in replaces that can do a bunch of stuff to computer and yeah, I'm just realizing how it clean. And that was just so much more. And user-friendly to Mac model is of, here's a thing you can click on it to run it and it'll do the thing that you expect. And if you don't like it, you can get rid of it as opposed to like, it's now fused with the operating system. You can never remove it completely.

Adam Wiggins (45:32):
And I do think that, you know, mobile operating systems do that even better and they even package the data with it. So it sort of all goes together when I deleted, it's deleted, it's gone now of course, mobile restricts you and limits you in so many other ways. That basic idea of first of all, the user's mental model, I think of, okay, an application I've installed it or have it now. And it's a tile on my home screen until I decide I don't want it anymore. And then I press it and tap, delete the title goes away. And there's this one-to-one association between the icon that lives in a particular place in this mildly spatial interface, the application code and data. And that I can basically manipulate it as one unit. And that's where I certainly feel like there's a very big lost opportunity for an user programming system, customizability, whatever, particularly on the iPad where I guess you can make short cuts and stuff like that.

Adam Wiggins (46:28):
But again, because of the review process, because the heavyweight tooling doesn't even run on that same platform, the idea of, yeah, I'd love everyone to do a little apps style thing on their iPad. You know, they're making it themselves in place and they type up that little program and they turn it into a tile that's on their home screen and data gets stored there. And if they want to send it to someone else, they can, if they want to move it to another device that can, if they want to delete it, they can. I think there's something very powerful office simplicity of that model, but then we haven't quite connected that together with the more programmability, so

Linus Lee (47:02):
The equation, right? I mean, it goes back to what mark was saying about to have that quality of experience of a stack fishermen. You need some constraints and I guess I was fine for them is providing some of those constraints so that you can have that simplicity, which has better API contracts for the era. Another example, more on the website that comes to mind is replica, which I'm a little biased because I worked there for a little bit, but one of the things that you can do with a replica, a rebel is a running environment, right? It's like code plus an execution environment and you can click a button and it's software and it's not perfect. There was some bit rod for like old things won't run because like some NPM package has gone out of date or something, but by and large, the promise of it is a ripple is like that, that packaged up thing with all the configuration.

Linus Lee (47:47):
There's a little database that you can talk to instead of rebel and things like that. And you hit run. And if you see someone else has the thing that you want to run, you can fork it, put it into your own account and then you can hit run. And now you have your own running instance and maybe the right solution kind of looks like that where you just abstract the whole thing, even at a higher level than like a Docker container or a Docker file. And you just say, here's an environment plus some code and you can look inside if you want, but really it's just a click run and it runs kind of experience.

Adam Wiggins (48:15):
Yeah, definitely put, wrap the lid in the same continuum of, I don't know if they think of themselves as a kind of platform as a service or serverless kind of environment, but I think it is in the same continuum with Roku, for example, the idea of wrapping it all up and then putting it on the web, which there's pros and cons to essentially running it on someone else's computer, but certainly for the use case of learning and getting started, I think that's sort of a no brainer. And of course over time that is becoming more and more powerful. Yeah. That also makes me think of code pen, which obviously is a much simpler use case because it's just some CSS and JavaScript it's all client side, et cetera, but it has a lot of that vibe and it creates a lot of that sharing dynamic, which is you search on there for, you know, find me a pen for, I don't know, doing parallax scrolling with whatever, whatever, or you find a couple of good examples. You find the one you want before you make some changes. Maybe that's has a little bit of some of the same vibe of the skinning modding gaming community you talked about earlier there, mark.

Linus Lee (49:13):
Exactly. And then once you have something like replicators and environments that you can spin up and sort of give to people, then it's really interesting to think about, well, what does an app store that's built on that model look like anywhere instead of downloaded things on your machine and running it there, you have sort of web software where there's like a replica app store or whatever. And instead of downloading a to-do app, you hit run and it clones that thing into your account. And then it spins up a little bit of backend code and a little bit of client code and you have your own web, but it's running just with your account and just with your data. And you can look at your data and you own all of that stuff out until you hit that cloud provider. But that I think is also really interesting to think about where you have sort of single user web apps and a way to distribute them. And then you can get people to have their little cloud environment with their little of apps instead of having your own computer, just have your own little cloud garden of things.

Adam Wiggins (50:07):
That's amazing.

Linus Lee (50:08):
The last interesting thing that I wanted to touch on was the idea of transparency in the transparency down the stack and down your tool. One thing that I've found that's really kind of gratifying as my own tools, especially not just at the top, but down to the language layer is just being able to understand what's happening. I think if you use a tool like notion, which I think is great, but it's very opaque. I type something in and it shows up on screen and I load that same page up on a different computer and it shows up on screen, but I have no idea how they're saving ad, how they're transforming out, where it's going, who owns it, whether it's in another continent and that's nice. And one way that it's packaged and kind of Hanoi, but building my own tools. I think an interesting benefit has been when I type a character in or hit save.

Linus Lee (50:52):
I know exactly where the bits are going. I know almost down to the CPU instruction, what's happening with the data. And I think that going back to the first thing that I mentioned, that changes the relationship that you have with your software, where it's, there's kind of a power dynamic where if you don't know what the company that's providing you, some software products is doing with your data or what's happening behind the scenes. They kind of have the power and you're paying them to, they let you use the thing. Whereas if you build your own thing, you understand exactly what's going on, that you're in control. And you can understand even just the concept of like the things that you use to run your day-to-day life. You have the power to understand fully, I think is kind of a radical idea

Adam Wiggins (51:30):
That comes back to this agency and this sense of, yeah, as we live in a world where there's more and more complexity to the technology and it becomes indistinguishable from magic and that's good in the sense that magic has great powers, more and more things in our lives, but then it's bad in the sense that we lose that understanding of it. That actually is important in the long run. I feel there may have been a star Trek, the next generation episode where they encounter. And if there were some humans or an alien race, I can't remember where kind of, they had forgotten how to service the technology or how it worked, you know, in generations past, because it works so well and it's kind of self-maintaining and that sort of thing. But then the whole civilization was in a state of not the K, but let's call it stasis or mild decay as a result of this. And they kind of explored philosophically that concept, which that shift was very good at doing.

Linus Lee (52:25):
Yeah. Maybe we went out so far away from that kind of thing, where there was another XKCD of like, you know, all of modern software. It depends on this one little piece that's maintained by some lonesome developer in the middle of nowhere, Arkansas or something. Yeah. These things are hugely complex. And there was a lot of parts that are sort of under service. My favorite variation of that joke is in the tools without space, one of the table stakes thing that you have to build when you build like a note taking or knowledge management top is you need a good bridge, text editing experience to be able to do things like bullet lists and things like that. And basically everybody that I know uses this library called pros mirror, which is amazing and excellent and really well designed and also quite complex, just conceptually. And it's just this one, dude, Ryan working on the library and he's like holding up an entire kind of versioning venture backed industry, which is sort of frightening and interesting thing about,

Adam Wiggins (53:18):
Well, it's a place to end thought. It'd be interesting to talk about software as kind of an ever evolving thing. Something that you finish. We talked about this in the filmmaking podcast with max backed, or you basically said films, you finish it, it's printed, that's it, it's done. You don't get to iterate on it. Any feedback you get and you think, oh man, I should've done that differently, too bad. Maybe it's a TV series. He could incorporate it the next season or whatever. And I've also tweeted about kind of, this is part of why the subscription model actually does make sense for software is that it sort of never done the tweet that I quoted. There was a curl maintainer speaking a little bit about the 23 years he spent working on that piece of software and it's still very active, new features, bug fixes for, what's basically a very simple tool. So how do you see that? Especially in the context of self-made tools where you can't maintain them, full-time particularly if you have a whole suite of them, how much can you build them as something that's finished versus now you've created for yourself a huge open-ended maintenance job or

Linus Lee (54:22):
Right. I think this goes back to what I spoke on earlier around if you have a software product that is in the line of business for some company or that a lot of people depend on like Karl is a great example where it does nominally does one thing, which is talk to some server on the web, but it's useful virtually every piece of electronics out there, but like, I'm sure my car, I don't have a car, but if I had a car, my car would use that in my fridge probably uses it or something like that. And then those things where these things sort of grow in an undoubted way, just because of user needs changing in the world, changing, I think it's difficult to be done with software. And I'm sure most of my side projects, if I really think about it, if you know something about Linux change or something about the HD protocol change or something like that, I have to rebuild it occasionally and fix some bugs.

Linus Lee (55:06):
But by and large, I think the benefit of having a single user and a very constrained well-defined use cases that you can kind of be done with software, like at least a single piece of software, like my notes app, it does a very constrained set of things that can write some text in it in a markdown format. I can save it, I can load it up and look at another device. And maybe there's some things that I want to add to it and occasion I can go back and add to it. But when I initially came up with it, I had a set of things that I wanted to do with it. And it does those things. I've mostly been fine with it and it's sort of done until something breaks. And I think if you build on stable foundations, as we talked about like go and the Linux user space and things like that, things don't break as much. So I think in that way, when you constrain those things a lot and kind of build for yourself, I do think it's possible to finish a piece of software.

Mark McGranaghan (55:56):
Yeah. I feel like in today's world, it needs to be a very deliberate act to create software that you expect to be finished because of the political economy, that software ecosystem. If you kind of write down what Google or stack overflow tells you to do this thing is not going to last a year before you have some package up the advisory or something, but you can, if you are very deliberate, build it in a way such that it might last three, five, even 10 years before it needs serious operations. Again, it kind of comes back to the idea artistic

Linus Lee (56:23):
Software and today even saying, I want this thing to be running in 10 years, without me being heavily involved with it is a major artistic statement to make. Right. Another thing that plays into this I think is also building many small things versus a single artist thing. At this point, I have a whole suite of these things I've noticed hop CRMs and sort clients on whatever, and they're all quite independent. Some of them rely on the same kinds of languages and frameworks and things like that. Like if one goes down, it doesn't matter for the other ones. And if you structure your sort of software ecosystem like that, then it's possible to like finish one piece and then if it needs to be improved and you can just replace that piece. And that way the whole system is kind of evolving continuously as the world changes.

Linus Lee (57:04):
Maybe I need, you know, but no topper context app that functions differently, but each a little Adam of that ecosystem is sort of finished, which I think just as a matter of fact, like a person working on these things, well, we'll down a full-time job is also kind of a necessity because being able to chunk these things up to Adams means that you can fit it into weekends. You're configured into these little breaks rather than having to work on them continuously. It's just a good conceptual model to work on these as well, to have an ecosystem of these atoms rather than a single sprawling kind of software grid.

Adam Wiggins (57:39):
Well, let's wrap it there. Thanks everyone for listening. If you have feedback, write us on Twitter at ease app HQ or on email. hello@newsapp.com. And it helps us if you leave a review on apple podcasts. So align us, thank you so much for being a role model, inspiring us to maybe creating that spark or that sense of it's doable for the thing we all want to do, whether it's that personal CRM or personal search tool. And I look forward to continuing to read your posts about whatever you're making next.

Linus Lee (58:09):
Thank you. Thanks for having me on the show.

